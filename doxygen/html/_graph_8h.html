<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DA_project01: Classes/Graph.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DA_project01<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_0c68614ac8d8401edbf4146ded722294.html">Classes</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Graph.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;queue&gt;</code><br />
<code>#include &lt;limits&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;unordered_set&gt;</code><br />
</div>
<p><a href="_graph_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_vertex.html">Vertex&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_edge.html">Edge&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html">Graph&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a12c2040f25d8e3a7b9e1c2024c618cb6" id="r_a12c2040f25d8e3a7b9e1c2024c618cb6"><td class="memItemLeft" align="right" valign="top">#<a class="el" href="class_edge.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12c2040f25d8e3a7b9e1c2024c618cb6">INF</a>&#160;&#160;&#160;std::numeric_limits&lt;<a class="el" href="class_edge.html">double</a>&gt;<a class="el" href="class_edge.html">::max</a>()</td></tr>
<tr class="separator:a12c2040f25d8e3a7b9e1c2024c618cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad56527992afe31a371065e795da57d25" id="r_ad56527992afe31a371065e795da57d25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad56527992afe31a371065e795da57d25">deleteMatrix</a> (<a class="el" href="class_edge.html">int</a> **<a class="el" href="class_edge.html">m</a>, <a class="el" href="class_edge.html">int</a> <a class="el" href="class_edge.html">n</a>)</td></tr>
<tr class="separator:ad56527992afe31a371065e795da57d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af077bc8682a1a1d97e30b08eb1131b19" id="r_af077bc8682a1a1d97e30b08eb1131b19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af077bc8682a1a1d97e30b08eb1131b19">deleteMatrix</a> (<a class="el" href="class_edge.html">double</a> **<a class="el" href="class_edge.html">m</a>, <a class="el" href="class_edge.html">int</a> <a class="el" href="class_edge.html">n</a>)</td></tr>
<tr class="separator:af077bc8682a1a1d97e30b08eb1131b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb329d42a9a476d072878ef35a6a343c" id="r_acb329d42a9a476d072878ef35a6a343c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="class_edge.html">class</a> <a class="el" href="class_edge.html">T</a> &gt; </td></tr>
<tr class="memitem:acb329d42a9a476d072878ef35a6a343c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acb329d42a9a476d072878ef35a6a343c">testAndVisit</a> (std::queue&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">T</a> &gt; * &gt; &amp;<a class="el" href="class_edge.html">q</a>, <a class="el" href="class_edge.html">Edge</a>&lt; <a class="el" href="class_edge.html">T</a> &gt; *<a class="el" href="class_edge.html">e</a>, <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">T</a> &gt; *<a class="el" href="class_edge.html">w</a>, <a class="el" href="class_edge.html">double</a> <a class="el" href="class_edge.html">residual</a>)</td></tr>
<tr class="memdesc:acb329d42a9a476d072878ef35a6a343c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests a vertex and visits it if necessary.  <br /></td></tr>
<tr class="separator:acb329d42a9a476d072878ef35a6a343c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef59ca73ad539b2405ee93bb9e1b8de" id="r_a7ef59ca73ad539b2405ee93bb9e1b8de"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="class_edge.html">class</a> <a class="el" href="class_edge.html">T</a> &gt; </td></tr>
<tr class="memitem:a7ef59ca73ad539b2405ee93bb9e1b8de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7ef59ca73ad539b2405ee93bb9e1b8de">findAugmentingPath</a> (<a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">T</a> &gt; *<a class="el" href="class_edge.html">g</a>, <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">T</a> &gt; *<a class="el" href="class_edge.html">s</a>, <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">T</a> &gt; *<a class="el" href="class_edge.html">t</a>)</td></tr>
<tr class="memdesc:a7ef59ca73ad539b2405ee93bb9e1b8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an augmenting path in the graph using BFS.  <br /></td></tr>
<tr class="separator:a7ef59ca73ad539b2405ee93bb9e1b8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38647bac4738e296aba7b1bc4744835" id="r_ab38647bac4738e296aba7b1bc4744835"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="class_edge.html">class</a> <a class="el" href="class_edge.html">T</a> &gt; </td></tr>
<tr class="memitem:ab38647bac4738e296aba7b1bc4744835"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab38647bac4738e296aba7b1bc4744835">findMinResidualAlongPath</a> (<a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">T</a> &gt; *<a class="el" href="class_edge.html">s</a>, <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">T</a> &gt; *<a class="el" href="class_edge.html">t</a>)</td></tr>
<tr class="memdesc:ab38647bac4738e296aba7b1bc4744835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the minimum residual capacity along an augmenting path.  <br /></td></tr>
<tr class="separator:ab38647bac4738e296aba7b1bc4744835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9813dc412187df7cc322afea1283c22c" id="r_a9813dc412187df7cc322afea1283c22c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="class_edge.html">class</a> <a class="el" href="class_edge.html">T</a> &gt; </td></tr>
<tr class="memitem:a9813dc412187df7cc322afea1283c22c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9813dc412187df7cc322afea1283c22c">augmentFlowAlongPath</a> (<a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">T</a> &gt; *<a class="el" href="class_edge.html">s</a>, <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">T</a> &gt; *<a class="el" href="class_edge.html">t</a>, <a class="el" href="class_edge.html">double</a> <a class="el" href="class_edge.html">f</a>)</td></tr>
<tr class="memdesc:a9813dc412187df7cc322afea1283c22c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Augments flow along an augmenting path in the graph.  <br /></td></tr>
<tr class="separator:a9813dc412187df7cc322afea1283c22c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4aa1e2e5bc60693999f7fccdd763f0" id="r_a3f4aa1e2e5bc60693999f7fccdd763f0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="class_edge.html">class</a> <a class="el" href="class_edge.html">T</a> &gt; </td></tr>
<tr class="memitem:a3f4aa1e2e5bc60693999f7fccdd763f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3f4aa1e2e5bc60693999f7fccdd763f0">initEdmondsKarp</a> (<a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">T</a> &gt; *<a class="el" href="class_edge.html">g</a>, <a class="el" href="class_station.html">Station</a> *<a class="el" href="class_edge.html">source</a>, <a class="el" href="class_station.html">Station</a> *<a class="el" href="class_edge.html">target</a>)</td></tr>
<tr class="memdesc:a3f4aa1e2e5bc60693999f7fccdd763f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the Edmonds-Karp algorithm and computes the maximum flow.  <br /></td></tr>
<tr class="separator:a3f4aa1e2e5bc60693999f7fccdd763f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652b0374820c128668326325e6b13eb8" id="r_a652b0374820c128668326325e6b13eb8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="class_edge.html">class</a> <a class="el" href="class_edge.html">T</a> &gt; </td></tr>
<tr class="memitem:a652b0374820c128668326325e6b13eb8"><td class="memTemplItemLeft" align="right" valign="top">std::unordered_set&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">T</a> &gt; * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a652b0374820c128668326325e6b13eb8">findAffectedSubset</a> (<a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">T</a> &gt; *<a class="el" href="class_edge.html">g</a>, <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">T</a> &gt; *<a class="el" href="class_edge.html">removedVertex</a>)</td></tr>
<tr class="memdesc:a652b0374820c128668326325e6b13eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the subset of vertices affected by the removal of a given vertex.  <br /></td></tr>
<tr class="separator:a652b0374820c128668326325e6b13eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6984e7258a7c03c9d6fbaaec5bcbd5" id="r_ade6984e7258a7c03c9d6fbaaec5bcbd5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="class_edge.html">class</a> <a class="el" href="class_edge.html">T</a> &gt; </td></tr>
<tr class="memitem:ade6984e7258a7c03c9d6fbaaec5bcbd5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ade6984e7258a7c03c9d6fbaaec5bcbd5">maxFlowIncremental</a> (<a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">T</a> &gt; &amp;graph, <a class="el" href="class_station.html">Station</a> *<a class="el" href="class_edge.html">source</a>, <a class="el" href="class_station.html">Station</a> *<a class="el" href="class_edge.html">sink</a>)</td></tr>
<tr class="memdesc:ade6984e7258a7c03c9d6fbaaec5bcbd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the maximum flow incrementally in a graph from a source to a sink.  <br /></td></tr>
<tr class="separator:ade6984e7258a7c03c9d6fbaaec5bcbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c14d9d7bfcd5818f9d2e6f2c78472d0" id="r_a7c14d9d7bfcd5818f9d2e6f2c78472d0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="class_edge.html">class</a> <a class="el" href="class_edge.html">T</a> &gt; </td></tr>
<tr class="memitem:a7c14d9d7bfcd5818f9d2e6f2c78472d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7c14d9d7bfcd5818f9d2e6f2c78472d0">discharge</a> (<a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">T</a> &gt; &amp;graph, <a class="el" href="class_edge.html">T</a> *<a class="el" href="class_edge.html">u</a>, <a class="el" href="class_edge.html">T</a> *<a class="el" href="class_edge.html">source</a>, <a class="el" href="class_edge.html">T</a> *<a class="el" href="class_edge.html">sink</a>, std::unordered_map&lt; <a class="el" href="class_edge.html">T</a> *, <a class="el" href="class_edge.html">double</a> &gt; &amp;<a class="el" href="class_edge.html">preflow</a>, std::unordered_map&lt; <a class="el" href="class_edge.html">T</a> *, <a class="el" href="class_edge.html">double</a> &gt; &amp;<a class="el" href="class_edge.html">height</a>, std::unordered_map&lt; <a class="el" href="class_edge.html">T</a> *, <a class="el" href="class_edge.html">double</a> &gt; &amp;<a class="el" href="class_edge.html">excess</a>, std::queue&lt; <a class="el" href="class_edge.html">T</a> * &gt; &amp;<a class="el" href="class_edge.html">activeNodes</a>)</td></tr>
<tr class="memdesc:a7c14d9d7bfcd5818f9d2e6f2c78472d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discharges excess flow from a node in the graph.  <br /></td></tr>
<tr class="separator:a7c14d9d7bfcd5818f9d2e6f2c78472d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb6892ea2df0c4d3b0654a15dc8b783" id="r_a5eb6892ea2df0c4d3b0654a15dc8b783"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="class_edge.html">class</a> <a class="el" href="class_edge.html">T</a> &gt; </td></tr>
<tr class="memitem:a5eb6892ea2df0c4d3b0654a15dc8b783"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5eb6892ea2df0c4d3b0654a15dc8b783">relabel</a> (<a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">T</a> &gt; &amp;graph, <a class="el" href="class_edge.html">T</a> *<a class="el" href="class_edge.html">u</a>, <a class="el" href="class_edge.html">T</a> *<a class="el" href="class_edge.html">source</a>, <a class="el" href="class_edge.html">T</a> *<a class="el" href="class_edge.html">sink</a>, std::unordered_map&lt; <a class="el" href="class_edge.html">T</a> *, <a class="el" href="class_edge.html">double</a> &gt; &amp;<a class="el" href="class_edge.html">preflow</a>, std::unordered_map&lt; <a class="el" href="class_edge.html">T</a> *, <a class="el" href="class_edge.html">double</a> &gt; &amp;<a class="el" href="class_edge.html">height</a>, std::unordered_map&lt; <a class="el" href="class_edge.html">T</a> *, <a class="el" href="class_edge.html">double</a> &gt; &amp;<a class="el" href="class_edge.html">excess</a>)</td></tr>
<tr class="memdesc:a5eb6892ea2df0c4d3b0654a15dc8b783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relabels a node in the graph to maintain the feasibility of the preflow.  <br /></td></tr>
<tr class="separator:a5eb6892ea2df0c4d3b0654a15dc8b783"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a12c2040f25d8e3a7b9e1c2024c618cb6" name="a12c2040f25d8e3a7b9e1c2024c618cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12c2040f25d8e3a7b9e1c2024c618cb6">&#9670;&#160;</a></span>INF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#<a class="el" href="class_edge.html">define</a> INF&#160;&#160;&#160;std::numeric_limits&lt;<a class="el" href="class_edge.html">double</a>&gt;<a class="el" href="class_edge.html">::max</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9813dc412187df7cc322afea1283c22c" name="a9813dc412187df7cc322afea1283c22c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9813dc412187df7cc322afea1283c22c">&#9670;&#160;</a></span>augmentFlowAlongPath()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="class_edge.html">class</a> <a class="el" href="class_edge.html">T</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> augmentFlowAlongPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">T</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">T</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>t</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">double</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Augments flow along an augmenting path in the graph. </p>
<p>This function augments flow along an augmenting path in the graph based on the minimum residual capacity found along the path.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in the graph vertices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The source vertex. </td></tr>
    <tr><td class="paramname">t</td><td>The target vertex. </td></tr>
    <tr><td class="paramname">f</td><td>The minimum residual capacity along the augmenting path. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af077bc8682a1a1d97e30b08eb1131b19" name="af077bc8682a1a1d97e30b08eb1131b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af077bc8682a1a1d97e30b08eb1131b19">&#9670;&#160;</a></span>deleteMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> deleteMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">double</a> **</td>          <td class="paramname"><span class="paramname"><em>m</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">int</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad56527992afe31a371065e795da57d25" name="ad56527992afe31a371065e795da57d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad56527992afe31a371065e795da57d25">&#9670;&#160;</a></span>deleteMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> deleteMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">int</a> **</td>          <td class="paramname"><span class="paramname"><em>m</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">int</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c14d9d7bfcd5818f9d2e6f2c78472d0" name="a7c14d9d7bfcd5818f9d2e6f2c78472d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c14d9d7bfcd5818f9d2e6f2c78472d0">&#9670;&#160;</a></span>discharge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="class_edge.html">class</a> <a class="el" href="class_edge.html">T</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> discharge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">T</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">T</a> *</td>          <td class="paramname"><span class="paramname"><em>u</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">T</a> *</td>          <td class="paramname"><span class="paramname"><em>source</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">T</a> *</td>          <td class="paramname"><span class="paramname"><em>sink</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; <a class="el" href="class_edge.html">T</a> *, <a class="el" href="class_edge.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>preflow</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; <a class="el" href="class_edge.html">T</a> *, <a class="el" href="class_edge.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>height</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; <a class="el" href="class_edge.html">T</a> *, <a class="el" href="class_edge.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>excess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::queue&lt; <a class="el" href="class_edge.html">T</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>activeNodes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discharges excess flow from a node in the graph. </p>
<p>This function is a theoretical proposal for discharging excess flow from a node in the graph. It is part of the relabel-to-front algorithm for calculating maximum flow incrementally. This function is not utilized in the project and is provided for theoretical discussion purposes.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data held by vertices in the graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>Reference to the graph structure. </td></tr>
    <tr><td class="paramname">u</td><td>Pointer to the node being discharged. </td></tr>
    <tr><td class="paramname">source</td><td>Pointer to the source station. </td></tr>
    <tr><td class="paramname">sink</td><td>Pointer to the sink station. </td></tr>
    <tr><td class="paramname">preflow</td><td>Map containing preflow values for nodes. </td></tr>
    <tr><td class="paramname">height</td><td>Map containing height values for nodes. </td></tr>
    <tr><td class="paramname">excess</td><td>Map containing excess flow values for nodes. </td></tr>
    <tr><td class="paramname">activeNodes</td><td>Queue containing active nodes in the algorithm. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a652b0374820c128668326325e6b13eb8" name="a652b0374820c128668326325e6b13eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a652b0374820c128668326325e6b13eb8">&#9670;&#160;</a></span>findAffectedSubset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="class_edge.html">class</a> <a class="el" href="class_edge.html">T</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">T</a> &gt; * &gt; findAffectedSubset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">T</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>g</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">T</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>removedVertex</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the subset of vertices affected by the removal of a given vertex. </p>
<p>This function is a theoretical proposal for a graph algorithm that we will use in the presentation. It finds the subset of vertices that are affected by the removal of a specified vertex from the graph. This function is not utilized in the project and is provided for theoretical discussion purposes.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data held by vertices in the graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Pointer to the graph structure. </td></tr>
    <tr><td class="paramname">removedVertex</td><td>Pointer to the vertex being removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An unordered set of vertices affected by the removal of the specified vertex. </dd></dl>

</div>
</div>
<a id="a7ef59ca73ad539b2405ee93bb9e1b8de" name="a7ef59ca73ad539b2405ee93bb9e1b8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef59ca73ad539b2405ee93bb9e1b8de">&#9670;&#160;</a></span>findAugmentingPath()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="class_edge.html">class</a> <a class="el" href="class_edge.html">T</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">bool</a> findAugmentingPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">T</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>g</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">T</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">T</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds an augmenting path in the graph using BFS. </p>
<p>This function finds an augmenting path in the graph using BFS traversal. It marks vertices as visited and explores edges to find paths from the source to the target vertex.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in the graph vertices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>A pointer to the graph. </td></tr>
    <tr><td class="paramname">s</td><td>The source vertex. </td></tr>
    <tr><td class="paramname">t</td><td>The target vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if an augmenting path is found, false otherwise. </dd></dl>

</div>
</div>
<a id="ab38647bac4738e296aba7b1bc4744835" name="ab38647bac4738e296aba7b1bc4744835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38647bac4738e296aba7b1bc4744835">&#9670;&#160;</a></span>findMinResidualAlongPath()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="class_edge.html">class</a> <a class="el" href="class_edge.html">T</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">double</a> findMinResidualAlongPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">T</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">T</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the minimum residual capacity along an augmenting path. </p>
<p>This function finds the minimum residual capacity along an augmenting path from the source to the target vertex.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in the graph vertices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The source vertex. </td></tr>
    <tr><td class="paramname">t</td><td>The target vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum residual capacity along the augmenting path. </dd></dl>

</div>
</div>
<a id="a3f4aa1e2e5bc60693999f7fccdd763f0" name="a3f4aa1e2e5bc60693999f7fccdd763f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f4aa1e2e5bc60693999f7fccdd763f0">&#9670;&#160;</a></span>initEdmondsKarp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="class_edge.html">class</a> <a class="el" href="class_edge.html">T</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">double</a> initEdmondsKarp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">T</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>g</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_station.html">Station</a> *</td>          <td class="paramname"><span class="paramname"><em>source</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_station.html">Station</a> *</td>          <td class="paramname"><span class="paramname"><em>target</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the Edmonds-Karp algorithm and computes the maximum flow. </p>
<p>This function initializes the Edmonds-Karp algorithm by setting up the graph and finding augmenting paths until no more augmenting paths can be found. It computes the maximum flow through the graph and returns the optimal flow value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in the graph vertices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>A pointer to the graph. </td></tr>
    <tr><td class="paramname">source</td><td>The source station. </td></tr>
    <tr><td class="paramname">target</td><td>The target station. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The optimal flow through the graph. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if source or target vertex is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Time Complexity: O(V * E^2) </dd></dl>

</div>
</div>
<a id="ade6984e7258a7c03c9d6fbaaec5bcbd5" name="ade6984e7258a7c03c9d6fbaaec5bcbd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade6984e7258a7c03c9d6fbaaec5bcbd5">&#9670;&#160;</a></span>maxFlowIncremental()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="class_edge.html">class</a> <a class="el" href="class_edge.html">T</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">double</a> maxFlowIncremental </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">T</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_station.html">Station</a> *</td>          <td class="paramname"><span class="paramname"><em>source</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_station.html">Station</a> *</td>          <td class="paramname"><span class="paramname"><em>sink</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the maximum flow incrementally in a graph from a source to a sink. </p>
<p>This function is a theoretical proposal for calculating the maximum flow in a graph incrementally. It implements the relabel-to-front algorithm. This function is not utilized in the project and is provided for theoretical discussion purposes.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data held by vertices in the graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>Reference to the graph structure. </td></tr>
    <tr><td class="paramname">source</td><td>Pointer to the source station. </td></tr>
    <tr><td class="paramname">sink</td><td>Pointer to the sink station. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total flow out of the source station. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time Complexity: O(E * V^2) </dd></dl>

</div>
</div>
<a id="a5eb6892ea2df0c4d3b0654a15dc8b783" name="a5eb6892ea2df0c4d3b0654a15dc8b783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb6892ea2df0c4d3b0654a15dc8b783">&#9670;&#160;</a></span>relabel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="class_edge.html">class</a> <a class="el" href="class_edge.html">T</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> relabel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">T</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">T</a> *</td>          <td class="paramname"><span class="paramname"><em>u</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">T</a> *</td>          <td class="paramname"><span class="paramname"><em>source</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">T</a> *</td>          <td class="paramname"><span class="paramname"><em>sink</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; <a class="el" href="class_edge.html">T</a> *, <a class="el" href="class_edge.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>preflow</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; <a class="el" href="class_edge.html">T</a> *, <a class="el" href="class_edge.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>height</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; <a class="el" href="class_edge.html">T</a> *, <a class="el" href="class_edge.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>excess</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relabels a node in the graph to maintain the feasibility of the preflow. </p>
<p>This function is a theoretical proposal for relabeling a node in the graph to maintain the feasibility of the preflow. It is part of the relabel-to-front algorithm for calculating maximum flow incrementally. This function is not utilized in the project and is provided for theoretical discussion purposes.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data held by vertices in the graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>Reference to the graph structure. </td></tr>
    <tr><td class="paramname">u</td><td>Pointer to the node being relabeled. </td></tr>
    <tr><td class="paramname">source</td><td>Pointer to the source station. </td></tr>
    <tr><td class="paramname">sink</td><td>Pointer to the sink station. </td></tr>
    <tr><td class="paramname">preflow</td><td>Map containing preflow values for nodes. </td></tr>
    <tr><td class="paramname">height</td><td>Map containing height values for nodes. </td></tr>
    <tr><td class="paramname">excess</td><td>Map containing excess flow values for nodes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb329d42a9a476d072878ef35a6a343c" name="acb329d42a9a476d072878ef35a6a343c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb329d42a9a476d072878ef35a6a343c">&#9670;&#160;</a></span>testAndVisit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="class_edge.html">class</a> <a class="el" href="class_edge.html">T</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> testAndVisit </td>
          <td>(</td>
          <td class="paramtype">std::queue&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">T</a> &gt; * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">Edge</a>&lt; <a class="el" href="class_edge.html">T</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>e</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">T</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>w</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">double</a></td>          <td class="paramname"><span class="paramname"><em>residual</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests a vertex and visits it if necessary. </p>
<p>This function tests a vertex to determine if it needs to be visited based on the residual capacity of an edge. If the vertex has not been visited and the residual capacity is greater than 0, the vertex is marked as visited, its path is set, and it is added to the queue.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data stored in the graph vertices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>A reference to the queue used for BFS traversal. </td></tr>
    <tr><td class="paramname">e</td><td>The edge being considered. </td></tr>
    <tr><td class="paramname">w</td><td>The vertex being tested and possibly visited. </td></tr>
    <tr><td class="paramname">residual</td><td>The residual capacity of the edge. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
